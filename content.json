[{"title":"JDK源码阅读-Iterable与Iterator","date":"2018-04-21T16:18:01.000Z","path":"2018/04/22/JDK源码阅读-Iterable与Iterator/","text":"JDK源码阅读-Iterable与Iterator JDK版本：jdk1.8.0_121,本文中所有代码的编译和运行环境均依赖该版本的jdk和对应版本的jre 1.什么是Iterable1.1简介Iterable是Java集合中的一个顶级接口，是Collection的父类，用于进行集合中元素的迭代。Iterable的方法定义如下： 12345678910111213141516171819package java.lang;import ...public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 这里面包含三个方法，其中forEach和spliterator这两个Java 1.8新增的default方法，关于什么是default方法，参考这里,(PS:Java为了向下兼容也是煞费苦心啊:dog:) 1.2 iterator()iterator()方法是Java1.5新增的特性，用于生成Iterator迭代器，这里该方法只负责生成Iterator迭代器，并不包含任何迭代器的状态，例如“当前元素”等。 而Iterator迭代器是作为一个独立的接口存在的。 该遍历是顺序遍历 1.3 forEach()forEach 很熟悉 用来支持lambda表达式的，例如: 123list.forEach(item-&gt;&#123; doSomething...;&#125;) 我们可以看到 在Iterable接口中默认给出的实现是 123for (T t : this) &#123; action.accept(t);&#125; 但是这个方法在子类中是可以被覆盖的，很多集合都对该方法进行了重写操作，以适应不同集合的特性。 1.4 spliterator()该接口是Java为了并行遍历数据源中的元素而设计的迭代器 该方法类似于iterator()这个方法，区别在于iterator()是顺序遍历，而spliterator()是并行遍历，具体可以参考这里Java8里面的java.util.Spliterator接口有什么用？ 2.什么是Iterator2.1 简介Iterator是具有迭代状态的对象，即从该类的方法中我们可以获取当前迭代的元素，下一个元素等操作。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。Iterator的定义如下： 1234567891011121314151617181920package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 2.2 hasNext()接口解释：用于判断迭代器(iteration)中是否还有更多的元素(elements)。如果迭代器中还有更多的元素则返回true。 2.3 next()接口解释：用于获取迭代器中的下一个元素(next element)，这里如果下一个元素不存在会抛出一个NoSuchElementException的异常，所以这个方法通常结合hasNext()一起使用。 2.4 remove():star::star:接口解释：用于从集合中移除迭代器返回的最后一个元素。这个方法只能在next()方法之后进行调用一次 这个方法会抛出两个异常 UnsupportedOperationException:表示当前迭代器不支持移除操作。 IllegalStateException:表示next()方法尚未执行 或 next()方法后已经执行了remove()方法。 这里有两个例子，如何在集合中移除一个元素的操作。 错误示范:x:: 123456List&lt;String&gt; list = Lists.newArrayList(\"A\",\"B\",\"C\",\"D\");for (String s : list) &#123; if (Objects.equals(\"A\",s))&#123; list.remove(s); &#125;&#125; 这里会抛出一个异常java.util.ConcurrentModificationException，表示 方法检测到对象的并发修改，但是这种修改并不被允许。 产生的原因就是迭代器是依赖于集合而存在，在判断成功后，集合的中移除了该元素，而迭代器却不知道，所以就报错了，这个错叫并发修改异常。 正确操作✅: 12345678List&lt;String&gt; list = Lists.newArrayList(\"A\", \"B\", \"C\", \"D\");Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String str = it.next(); if (Objects.equals(\"A\", str)) &#123; it.remove(); &#125;&#125; 在Java8中上面的代码可以用下面两行来完成： 12List&lt;String&gt; list = Lists.newArrayList(\"A\", \"B\", \"C\", \"D\");list.removeIf(str -&gt; Objects.equals(\"A\", str)); 这两种方式都是可以正确的完成我们所需要的操作的。 2.5 forEachRemaining()这个方法是1.8新增的方法，对每个剩余的元素执行给定的操作，直到所有元素都执行完成或者抛出异常。 如果传入的操作(Consumer&lt;? super E&gt; action)为空的话，该方法会抛出一个NullPointerException 3.Iterator的实现我们可以看到Iterator提供了最简单的向后遍历的操作接口，如果我们需要执行向前遍历呢？或者执行某些特殊的遍历方式，那么这个时候就要看不同集合对Iterator的实现了，不同集合的对于Iterator的实现基本都是通过内部类来做的实现。 3.1 ArrayList中Iterator的实现3.1.1 Itr在ArrayList中，iterator()方法被返回了一个Itr的对象。 1234// ArrArrayList.javapublic Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这个Itr对象就是对ArrayList对Iterator的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private class Itr implements Iterator&lt;E&gt; &#123; // 被返回的节点的索引 int cursor; // index of next element to return、 // 最后一个被返回的节点的索引 int lastRet = -1; // index of last element returned; -1 if no such // expectedModCount 期望的被修改的次数， // modCount 被修改的次数,这个下面会用得到。定义modCount的注释翻译可以参考[这里](https://blog.csdn.net/qq_27093465/article/details/53116250) int expectedModCount = modCount; /** * 判断是否还有下一个元素,如果当前游标所在位置不等于集合的大小的时候都会返回true. */ public boolean hasNext() &#123; return cursor != size; &#125; /** * next操作 */ public E next() &#123; // 校验是否被非法修改 checkForComodification(); int i = cursor; // 当前游标大于等于集合的大小的时候 抛出异常 if (i &gt;= size) throw new NoSuchElementException(); // 存储ArrayList的数组缓冲区的大小 Object[] elementData = ArrayList.this.elementData; // 如果游标大于等于数组缓冲区的大小则抛出异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // 游标+1 cursor = i + 1; // 获取对应下表的内容，进行强转， 并将当前访问的节点记录到lastRet中， return (E) elementData[lastRet = i]; &#125; /** * 移除操作 */ public void remove() &#123; // lastRet小于0，即表示没有执行next操作，也就是不存在当前元素。 if (lastRet &lt; 0) throw new IllegalStateException(); // 校验是否被非法修改 checkForComodification(); try &#123; // 将最后一次访问的节点移除 ArrayList.this.remove(lastRet); // 更新 游标，😈我们直接执行list中的remove方法就是因为没有更新游标和expectedModCount，所以无法通过校验。 cursor = lastRet; // 更改最后一次访问的索引为-1，此处因为最后一次访问的元素已经不存在了，所以更新为-1，同时也可以避免再次调用remove方法。 lastRet = -1; // 更新修改次数 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; // 捕获remove过程中出现的数组下标越界异常，更改为非法修改异常。 throw new ConcurrentModificationException(); &#125; &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; // final 防止这个方法被非法修改 final void checkForComodification() &#123; // 校验修改次数和期望的修改次数是否相同，remove是一个典型的例子。Itr中的remove方法更新了expectedModCount，而list中remove方法并没有，所以我们可以使用Iterator进行遍历删除。 if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 3.1.1 ListItr在ArrayList中，还有一个listIterator()方法被返回了一个ListIterator的对象。那么这个对象是干啥的呢？ 1234567891011121314/** * 从指定位置开始返回一个迭代器，如果位置超过了List的大小，则抛出IndexOutOfBoundsException */public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index);&#125;/** * 返回一个从0开始的迭代器 */public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; 这个方法在Itr基础上提供了一些List集合特有的遍历方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 继承了Itr，实现了ListIterator接口，ListIterator接口中定义了List集合一些特有的遍历方法private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; // 构造方法，可以指定迭代器的起始位置，即cursor的位置 ListItr(int index) &#123; super(); cursor = index; &#125; // 是否有前一个元素 public boolean hasPrevious() &#123; // 判断游标是否是在最前面 return cursor != 0; &#125; // 后一个元素的位置 public int nextIndex() &#123; return cursor; &#125; // 前一个元素的位置 public int previousIndex() &#123; return cursor - 1; &#125; // 前一个元素 public E previous() &#123; // 校验是否被非法修改(Itr中的方法) checkForComodification(); // 确定前一个元素的位置 int i = cursor - 1; // 前一个元素如果小于0则表示当前是起始节点，上一个节点不存在。 if (i &lt; 0) throw new NoSuchElementException(); // 剩下的和next()同理 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; // 替换当前元素 public void set(E e) &#123; // 判断当前元素是否存在，同理的类似于remove() if (lastRet &lt; 0) throw new IllegalStateException(); // 校验是否被非法修改 checkForComodification(); try &#123; // 修改缓冲区数组的值 ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 增加一个值(原理同remove()) public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 4.迭代器模式实现了Iterable接口的类是可迭代的；实现了Iterator接口的类是一个迭代器。 这里算是一个迭代器模式，即提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。 4.1 类图 迭代器类图 4.2 迭代器模式的结构 抽象容器(Aggregate):通常是一个接口，提供iterator()方法，比如说Java中的Iterator接口，Collection接口，Set接口等。 具体容器(ConcreteAggregate):抽象容器的具体实现类，比如说ArrayList，LinkList，HashSet等。 抽象迭代器(Iterator):定义遍历元素所需要的方法，比如说：next()，hasNext()，remove()等方法。 迭代器实现(ConcreteIterator):实现迭代器接口中定义的方法，完成集合的迭代。","tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"http://xiaomogu.me/tags/JDK源码/"},{"name":"Java基础","slug":"Java基础","permalink":"http://xiaomogu.me/tags/Java基础/"},{"name":"设计模式","slug":"设计模式","permalink":"http://xiaomogu.me/tags/设计模式/"}]},{"title":"Dockerfile中`ADD`和`COPY`的区别","date":"2018-04-10T09:34:54.000Z","path":"2018/04/10/Dockerfile中`ADD`和`COPY`的区别/","text":"Dockerfile中ADD和COPY的区别 本文来自Best practices for writing Dockerfiles 建议编写Dockerfile前先熟读上文 Dockerfile 中提供了两种复制文件的方式：ADD和COPY，这两种方式有什么区别呢？这两者分别在什么时候使用呢? ADD和COPY功能相似，COPY是首选。因为它比ADD更加透明.COPY仅支持基础的本地文件拷贝到容器中，ADD有些特性(本地tar包解压和远程URL支持) ，这些特性并不是很明显。ADD最好的应用是本地tar包自动解压到镜像中，如ADD rootfs.tar.xz /。 如果我们在Dockerfile中有多个步骤使用不同文件，逐个COPY这些文件，而不是拷贝所有文件。这样确保每步骤的缓存会还重新更新。 123COPY requirements.txt /tmp/RUN pip install --requirement /tmp/requirements.txtCOPY . /tmp/ 出于镜像大小考虑，强烈不建议使用ADD获取远程URL地址的包，我们应该使用curl或者wget替代。这样我们可以在解压后删除不用的文件，而不必添加到镜像的另一层。我们避免使用如下形式: 123ADD http://example.com/big.tar.xz /usr/src/things/RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/thingsRUN make -C /usr/src/things all 应该替换成如下形式: 1234RUN mkdir -p /usr/src/things \\ &amp;&amp; curl -SL http://example.com/big.tar.xz \\ | tar -xJC /usr/src/things \\ &amp;&amp; make -C /usr/src/things all","tags":[{"name":"Docker","slug":"Docker","permalink":"http://xiaomogu.me/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://xiaomogu.me/tags/Dockerfile/"}]},{"title":"Dockerfile 导入证书到JAVA的秘钥库中","date":"2018-04-10T01:07:41.652Z","path":"2018/04/10/Dockerfile 导入证书到JAVA的秘钥库中/","text":"Dockerfile 导入证书到JAVA的秘钥库中目的:将已有的CA证书导入到通过Dockerfile导入到JAVA的秘钥库中。 12345678FROM custom/oraclejdk:8-jre8COPY ./tomcat.cer /tomcat.cerRUN $JAVA_HOME/bin/keytool -storepasswd -new mysecretpassword -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit &amp;&amp; \\ echo 'yes' | $JAVA_HOME/bin/keytool -import -alias passport.sso.com -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file /tomcat.cer -trustcacerts -storepass mysecretpasswordCOPY ./uums.jar /home/uums.jarCMD [\"java\",\"-Dspring.profiles.active=test\",\"-jar\",\"/home/uums.jar\"] 解释： 1$JAVA_HOME/bin/keytool -storepasswd -new mysecretpassword -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit 上面这句话的目的是将changeit这个密码存储到秘钥库中 1echo 'yes' | $JAVA_HOME/bin/keytool -import -alias passport.sso.com -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file /tomcat.cer -trustcacerts -storepass mysecretpassword 此处是导入证书，-storepass mysecretpassword,这句话是指定我们上一步存储的密码名称。这一行如果单独执行的话是需要输入yes来信任该证书的，我们可以通过echo &#39;yes&#39;这种写法来实现yes的自动输入。 参考： Inserting certificates into Java keystore via Dockerfile java中Keytool的使用总结","tags":[{"name":"Docker","slug":"Docker","permalink":"http://xiaomogu.me/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://xiaomogu.me/tags/Dockerfile/"}]},{"title":"Mybatis 初始化过程","date":"2018-03-19T06:27:59.401Z","path":"2018/03/19/Mybatis 初始化过程/","text":"Mybatis 初始化过程 Mybatis的初始化就是将Mybatis的配置信息加载到Configuration这个类中，以便后面的使用。 Mybatis的初始化流程，下面是一段Mybatis从加载配置到执行SQL语句的完整过程的代码(该代码来自Mybatis的测试类) Mybatis测试代码1 下面我们来一步一步的分析 读取配置文件 我们可以看到首先使用的是Resources这个类读取的配置文件，以流的形式读取到程序中，返回一个Reader。 加载配置文件 这一步将上面读取的reader作为参数传递给SqlSessionFactoryBuilder用于构建SqlSessionFactory。 SqlSessionFactoryBuilder 该类提供了许多重载的方法供我们选择。 此类的核心就是将我们传入的Reader或者InputStream通过XMLConfigBuilder类的parse方法，构造成Configuration，然后通过第91行的build方法，构造一个SqlSessionFactory并返回。 配置文件解析过程 12XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);return build(parser.parse()); 配置文件解析的入口就是在这里。根据读取配置文件时传入的Reader或者InputStream分别调用XMLConfigBuilder不同的构造器，实例化出XMLConfigBuilder,然后调用XMLConfigBuilder类中的parse()方法,构造出我们需要的Configuration。 123public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);&#125; 这是构建XMLConfigBuilder的具体方法。这个地方的构造过程如下 先实例化XMLMapperEntityResolver,然后将其作为实例化XPathParser的参数之一，最后实例化XMLConfigBuilder 实例化XMLMapperEntityResolver的过程很简单，调用的是其无参构造函数，XMLMapperEntityResolver里面包含了一些Mybatis的DTD。该类对外暴露了一个public InputSource resolveEntity(String publicId, String systemId)的方法，用于寻找根据publicId和systemId,寻找对应的DTD文件。 实例化XPathParser 1234public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) &#123; commonConstructor(validation, variables, entityResolver); this.document = createDocument(new InputSource(inputStream));&#125; inputStream就是我们传入的配置文件的流的信息，entityResolver是我们刚刚实例化的XMLMapperEntityResolver。首先调用了commonConstructor 12345678private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) &#123; this.validation = validation; this.entityResolver = entityResolver; this.variables = variables; // 实例化一个XPath工厂，用于生产XPath XPathFactory factory = XPathFactory.newInstance(); this.xpath = factory.newXPath();&#125; 执行完commonConstructor之后就是创建Document了,这一块没啥重点，解析XML成Document对象而已。 1234567891011121314151617181920212223242526272829303132333435363738private Document createDocument(InputSource inputSource) &#123; // important: this must only be called AFTER common constructor try &#123; // 创建一个用于创建DocumentBuilder的工厂，并给工厂设置一些参数 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setValidating(validation); factory.setNamespaceAware(false); factory.setIgnoringComments(true); factory.setIgnoringElementContentWhitespace(false); factory.setCoalescing(false); factory.setExpandEntityReferences(true); // 通过工厂创建一个用于创建Document的builder DocumentBuilder builder = factory.newDocumentBuilder(); // 设置一些参数 builder.setEntityResolver(entityResolver); builder.setErrorHandler(new ErrorHandler() &#123; @Override public void error(SAXParseException exception) throws SAXException &#123; throw exception; &#125; @Override public void fatalError(SAXParseException exception) throws SAXException &#123; throw exception; &#125; @Override public void warning(SAXParseException exception) throws SAXException &#123; &#125; &#125;); // 解析输入的流创建Document return builder.parse(inputSource); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error creating document instance. Cause: \" + e, e); &#125;&#125; 都创建完了，我们再回到真正执行XMLConfigBuilder创建的方法。 1234567891011private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; // 通过父类调用Configuration的无参构造方法 super(new Configuration()); ErrorContext.instance().resource(\"SQL Mapper Configuration\"); this.configuration.setVariables(props); // 确保只执行一次，调用parse()方法时，会将其设置为true this.parsed = false; this.environment = environment; // 这个是重点，后面会用到 this.parser = parser;&#125; 至于new Configuration()具体干了啥，我们可以看一下源码。 123456789101112131415161718192021222324252627282930313233public Configuration() &#123; typeAliasRegistry.registerAlias(\"JDBC\", JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(\"MANAGED\", ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(\"JNDI\", JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(\"POOLED\", PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(\"UNPOOLED\", UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(\"PERPETUAL\", PerpetualCache.class); typeAliasRegistry.registerAlias(\"FIFO\", FifoCache.class); typeAliasRegistry.registerAlias(\"LRU\", LruCache.class); typeAliasRegistry.registerAlias(\"SOFT\", SoftCache.class); typeAliasRegistry.registerAlias(\"WEAK\", WeakCache.class); typeAliasRegistry.registerAlias(\"DB_VENDOR\", VendorDatabaseIdProvider.class); typeAliasRegistry.registerAlias(\"XML\", XMLLanguageDriver.class); typeAliasRegistry.registerAlias(\"RAW\", RawLanguageDriver.class); typeAliasRegistry.registerAlias(\"SLF4J\", Slf4jImpl.class); typeAliasRegistry.registerAlias(\"COMMONS_LOGGING\", JakartaCommonsLoggingImpl.class); typeAliasRegistry.registerAlias(\"LOG4J\", Log4jImpl.class); typeAliasRegistry.registerAlias(\"LOG4J2\", Log4j2Impl.class); typeAliasRegistry.registerAlias(\"JDK_LOGGING\", Jdk14LoggingImpl.class); typeAliasRegistry.registerAlias(\"STDOUT_LOGGING\", StdOutImpl.class); typeAliasRegistry.registerAlias(\"NO_LOGGING\", NoLoggingImpl.class); typeAliasRegistry.registerAlias(\"CGLIB\", CglibProxyFactory.class); typeAliasRegistry.registerAlias(\"JAVASSIST\", JavassistProxyFactory.class); languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class); languageRegistry.register(RawLanguageDriver.class);&#125; 我们可以看到，这个无参的构造方法主要是注册了一系列的别名，这个我们另行分析，我们先往下看。 XMLConfigBuilder实例化完成以后就是调用其parse()方法完成一系列配置文件的解析，和对Configuration的装配。 123456789101112public Configuration parse() &#123; // 保证只被解析一次。 if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; // 解析根节点(至于这个evalNode是如何执行的，可以参照XPath解析xml相关的文章) XNode xNode = parser.evalNode(\"/configuration\"); // 解析根节点下面的子节点 parseConfiguration(xNode); return configuration;&#125; 123456789101112131415161718192021private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); Properties settings = settingsAsProperties(root.evalNode(\"settings\")); loadCustomVfs(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125; 这是解析Configuration下面的11个子节点，并装配到Configuration中，具体解析过程可以点进去详细查看。 执行完整个parse()的过程，返回Configuration整个初始化流程也就结束了。","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaomogu.me/tags/Mybatis/"}]},{"title":"Git基础命令","date":"2018-03-01T00:09:58.660Z","path":"2018/03/01/Git基础命令/","text":"初始化仓库 1git init 查看仓库日志 1git log 查看仓库状态 1git status 添加文件 1git add filename 添加所有文件 1git add -A . 提交 1git commit -m \"&lt;commit message&gt;\" 添加远程仓库地址 1git remote add origin &lt;repository URL&gt; 推送到远程仓库 1git push -u origin master // 注释:远程分支为origin，默认的本地分支为master，-u是记住提交参数，下次可以直接使用git push 进行提交 拉取远程仓库 1git pull origin master // 注释:同上 查看最近一次提交的更改 1git diff HEAD //注释:HEAD为指针,diff的另一个重要用途是查看已经暂存文件内的更改。记住，staged文件是我们告诉git已准备好提交的文件。 取消暂存 1git reset &lt;filename&gt; //注释:从暂存区移除指定文件 撤销 1git checkout -- &lt;filename&gt; //注释:重新检出某个文件，恢复为最后一次commit的状态 创建分支 1git branch &lt;new_branch&gt; 切换分支 1git checkout &lt;branch&gt; 创建并切换分支 1git checkout -b &lt;new_branch&gt; //注释:13、14两条命令的合并 移除文件 1git rm '&lt;filename&gt;' //注释：此操作会同时从磁盘，暂存区移除指定文件 合并分支到master 1git merge &lt;branch&gt; 移除分支 1git branch -d &lt;branch&gt; 相关链接： try git Pro Git 中文版","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaomogu.me/tags/Git/"}]}]