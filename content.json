[{"title":"Dockerfile 导入证书到JAVA的秘钥库中","date":"2018-04-10T01:07:41.652Z","path":"2018/04/10/Dockerfile 导入证书到JAVA的秘钥库中/","text":"Dockerfile 导入证书到JAVA的秘钥库中目的:将已有的CA证书导入到通过Dockerfile导入到JAVA的秘钥库中。 12345678FROM custom/oraclejdk:8-jre8COPY ./tomcat.cer /tomcat.cerRUN $JAVA_HOME/bin/keytool -storepasswd -new mysecretpassword -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit &amp;&amp; \\ echo 'yes' | $JAVA_HOME/bin/keytool -import -alias passport.sso.com -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file /tomcat.cer -trustcacerts -storepass mysecretpasswordCOPY ./uums.jar /home/uums.jarCMD [\"java\",\"-Dspring.profiles.active=test\",\"-jar\",\"/home/uums.jar\"] 解释： 1$JAVA_HOME/bin/keytool -storepasswd -new mysecretpassword -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit 上面这句话的目的是将changeit这个密码存储到秘钥库中 1echo 'yes' | $JAVA_HOME/bin/keytool -import -alias passport.sso.com -keystore $&#123;JAVA_HOME&#125;/jre/lib/security/cacerts -file /tomcat.cer -trustcacerts -storepass mysecretpassword 此处是导入证书，-storepass mysecretpassword,这句话是指定我们上一步存储的密码名称。这一行如果单独执行的话是需要输入yes来信任该证书的，我们可以通过echo &#39;yes&#39;这种写法来实现yes的自动输入。 参考： Inserting certificates into Java keystore via Dockerfile java中Keytool的使用总结","tags":[{"name":"Docker","slug":"Docker","permalink":"http://xiaomogu.me/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://xiaomogu.me/tags/Dockerfile/"}]},{"title":"Mybatis 初始化过程","date":"2018-03-19T06:27:59.401Z","path":"2018/03/19/Mybatis 初始化过程/","text":"Mybatis 初始化过程 Mybatis的初始化就是将Mybatis的配置信息加载到Configuration这个类中，以便后面的使用。 Mybatis的初始化流程，下面是一段Mybatis从加载配置到执行SQL语句的完整过程的代码(该代码来自Mybatis的测试类) Mybatis测试代码1 下面我们来一步一步的分析 读取配置文件 我们可以看到首先使用的是Resources这个类读取的配置文件，以流的形式读取到程序中，返回一个Reader。 加载配置文件 这一步将上面读取的reader作为参数传递给SqlSessionFactoryBuilder用于构建SqlSessionFactory。 SqlSessionFactoryBuilder 该类提供了许多重载的方法供我们选择。 此类的核心就是将我们传入的Reader或者InputStream通过XMLConfigBuilder类的parse方法，构造成Configuration，然后通过第91行的build方法，构造一个SqlSessionFactory并返回。 配置文件解析过程 12XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);return build(parser.parse()); 配置文件解析的入口就是在这里。根据读取配置文件时传入的Reader或者InputStream分别调用XMLConfigBuilder不同的构造器，实例化出XMLConfigBuilder,然后调用XMLConfigBuilder类中的parse()方法,构造出我们需要的Configuration。 123public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);&#125; 这是构建XMLConfigBuilder的具体方法。这个地方的构造过程如下 先实例化XMLMapperEntityResolver,然后将其作为实例化XPathParser的参数之一，最后实例化XMLConfigBuilder 实例化XMLMapperEntityResolver的过程很简单，调用的是其无参构造函数，XMLMapperEntityResolver里面包含了一些Mybatis的DTD。该类对外暴露了一个public InputSource resolveEntity(String publicId, String systemId)的方法，用于寻找根据publicId和systemId,寻找对应的DTD文件。 实例化XPathParser 1234public XPathParser(InputStream inputStream, boolean validation, Properties variables, EntityResolver entityResolver) &#123; commonConstructor(validation, variables, entityResolver); this.document = createDocument(new InputSource(inputStream));&#125; inputStream就是我们传入的配置文件的流的信息，entityResolver是我们刚刚实例化的XMLMapperEntityResolver。首先调用了commonConstructor 12345678private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) &#123; this.validation = validation; this.entityResolver = entityResolver; this.variables = variables; // 实例化一个XPath工厂，用于生产XPath XPathFactory factory = XPathFactory.newInstance(); this.xpath = factory.newXPath();&#125; 执行完commonConstructor之后就是创建Document了,这一块没啥重点，解析XML成Document对象而已。 1234567891011121314151617181920212223242526272829303132333435363738private Document createDocument(InputSource inputSource) &#123; // important: this must only be called AFTER common constructor try &#123; // 创建一个用于创建DocumentBuilder的工厂，并给工厂设置一些参数 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setValidating(validation); factory.setNamespaceAware(false); factory.setIgnoringComments(true); factory.setIgnoringElementContentWhitespace(false); factory.setCoalescing(false); factory.setExpandEntityReferences(true); // 通过工厂创建一个用于创建Document的builder DocumentBuilder builder = factory.newDocumentBuilder(); // 设置一些参数 builder.setEntityResolver(entityResolver); builder.setErrorHandler(new ErrorHandler() &#123; @Override public void error(SAXParseException exception) throws SAXException &#123; throw exception; &#125; @Override public void fatalError(SAXParseException exception) throws SAXException &#123; throw exception; &#125; @Override public void warning(SAXParseException exception) throws SAXException &#123; &#125; &#125;); // 解析输入的流创建Document return builder.parse(inputSource); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error creating document instance. Cause: \" + e, e); &#125;&#125; 都创建完了，我们再回到真正执行XMLConfigBuilder创建的方法。 1234567891011private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; // 通过父类调用Configuration的无参构造方法 super(new Configuration()); ErrorContext.instance().resource(\"SQL Mapper Configuration\"); this.configuration.setVariables(props); // 确保只执行一次，调用parse()方法时，会将其设置为true this.parsed = false; this.environment = environment; // 这个是重点，后面会用到 this.parser = parser;&#125; 至于new Configuration()具体干了啥，我们可以看一下源码。 123456789101112131415161718192021222324252627282930313233public Configuration() &#123; typeAliasRegistry.registerAlias(\"JDBC\", JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(\"MANAGED\", ManagedTransactionFactory.class); typeAliasRegistry.registerAlias(\"JNDI\", JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(\"POOLED\", PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(\"UNPOOLED\", UnpooledDataSourceFactory.class); typeAliasRegistry.registerAlias(\"PERPETUAL\", PerpetualCache.class); typeAliasRegistry.registerAlias(\"FIFO\", FifoCache.class); typeAliasRegistry.registerAlias(\"LRU\", LruCache.class); typeAliasRegistry.registerAlias(\"SOFT\", SoftCache.class); typeAliasRegistry.registerAlias(\"WEAK\", WeakCache.class); typeAliasRegistry.registerAlias(\"DB_VENDOR\", VendorDatabaseIdProvider.class); typeAliasRegistry.registerAlias(\"XML\", XMLLanguageDriver.class); typeAliasRegistry.registerAlias(\"RAW\", RawLanguageDriver.class); typeAliasRegistry.registerAlias(\"SLF4J\", Slf4jImpl.class); typeAliasRegistry.registerAlias(\"COMMONS_LOGGING\", JakartaCommonsLoggingImpl.class); typeAliasRegistry.registerAlias(\"LOG4J\", Log4jImpl.class); typeAliasRegistry.registerAlias(\"LOG4J2\", Log4j2Impl.class); typeAliasRegistry.registerAlias(\"JDK_LOGGING\", Jdk14LoggingImpl.class); typeAliasRegistry.registerAlias(\"STDOUT_LOGGING\", StdOutImpl.class); typeAliasRegistry.registerAlias(\"NO_LOGGING\", NoLoggingImpl.class); typeAliasRegistry.registerAlias(\"CGLIB\", CglibProxyFactory.class); typeAliasRegistry.registerAlias(\"JAVASSIST\", JavassistProxyFactory.class); languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class); languageRegistry.register(RawLanguageDriver.class);&#125; 我们可以看到，这个无参的构造方法主要是注册了一系列的别名，这个我们另行分析，我们先往下看。 XMLConfigBuilder实例化完成以后就是调用其parse()方法完成一系列配置文件的解析，和对Configuration的装配。 123456789101112public Configuration parse() &#123; // 保证只被解析一次。 if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; // 解析根节点(至于这个evalNode是如何执行的，可以参照XPath解析xml相关的文章) XNode xNode = parser.evalNode(\"/configuration\"); // 解析根节点下面的子节点 parseConfiguration(xNode); return configuration;&#125; 123456789101112131415161718192021private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); Properties settings = settingsAsProperties(root.evalNode(\"settings\")); loadCustomVfs(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125; 这是解析Configuration下面的11个子节点，并装配到Configuration中，具体解析过程可以点进去详细查看。 执行完整个parse()的过程，返回Configuration整个初始化流程也就结束了。","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaomogu.me/tags/Mybatis/"}]},{"title":"Git基础命令","date":"2018-03-01T00:09:58.660Z","path":"2018/03/01/Git基础命令/","text":"初始化仓库 1git init 查看仓库日志 1git log 查看仓库状态 1git status 添加文件 1git add filename 添加所有文件 1git add -A . 提交 1git commit -m \"&lt;commit message&gt;\" 添加远程仓库地址 1git remote add origin &lt;repository URL&gt; 推送到远程仓库 1git push -u origin master // 注释:远程分支为origin，默认的本地分支为master，-u是记住提交参数，下次可以直接使用git push 进行提交 拉取远程仓库 1git pull origin master // 注释:同上 查看最近一次提交的更改 1git diff HEAD //注释:HEAD为指针,diff的另一个重要用途是查看已经暂存文件内的更改。记住，staged文件是我们告诉git已准备好提交的文件。 取消暂存 1git reset &lt;filename&gt; //注释:从暂存区移除指定文件 撤销 1git checkout -- &lt;filename&gt; //注释:重新检出某个文件，恢复为最后一次commit的状态 创建分支 1git branch &lt;new_branch&gt; 切换分支 1git checkout &lt;branch&gt; 创建并切换分支 1git checkout -b &lt;new_branch&gt; //注释:13、14两条命令的合并 移除文件 1git rm '&lt;filename&gt;' //注释：此操作会同时从磁盘，暂存区移除指定文件 合并分支到master 1git merge &lt;branch&gt; 移除分支 1git branch -d &lt;branch&gt; 相关链接： try git Pro Git 中文版","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaomogu.me/tags/Git/"}]},{"title":"Hello World","date":"2018-02-10T15:36:16.000Z","path":"2018/02/10/hello-world/","text":"title: Hello World 测试3Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"测试2","slug":"测试2","permalink":"http://xiaomogu.me/tags/测试2/"}]}]